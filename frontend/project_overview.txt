# VigilantEx Sales Automation App - Project Overview

## Project Structure
```
/dist_clean/frontend/
  - index.html
  - node_modules/
  - package-lock.json
  - package.json
  - public/
  - src/
    - App.jsx
    - assets/
    - components/
      - common/
        - Button.jsx
        - LoadingSpinner.jsx
      - forms/
        - InputForm.jsx
      - results/
        - ResultsDisplay.jsx
      - visualization/
        - AIVisualization.jsx
    - context/
      - AppContext.jsx
    - hooks/
    - index.css
    - main.jsx
    - services/
      - apiService.js
    - utils/
  - tailwind.config.js
  - vite.config.js
```

## Project Code

### /package.json
```json
{
  "name": "frontend",
  "version": "1.0.0",
  "description": "VigilantEx Sales Automation App Frontend",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "keywords": [
    "vigilantex",
    "sales",
    "automation",
    "ai",
    "threejs",
    "react"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@react-three/drei": "^10.0.4",
    "@react-three/fiber": "^9.1.0",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.21",
    "axios": "^1.8.4",
    "postcss": "^8.5.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwindcss": "^4.0.15",
    "three": "^0.174.0"
  },
  "devDependencies": {
    "vite": "^6.2.2"
  }
}
```

### /src/main.jsx
```jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
```

### /src/App.jsx
```jsx
import React, { useState, Suspense } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import AIVisualization from './components/visualization/AIVisualization';
import InputForm from './components/forms/InputForm';
import ResultsDisplay from './components/results/ResultsDisplay';
import LoadingSpinner from './components/common/LoadingSpinner';
import { AppProvider } from './context/AppContext';

function App() {
  const [activeTab, setActiveTab] = useState('profile'); // 'profile', 'company', or 'message'
  
  return (
    <AppProvider>
      <div className="flex flex-col h-screen bg-gray-100">
        <header className="bg-white shadow-md p-4">
          <div className="container mx-auto flex justify-between items-center">
            <h1 className="text-2xl font-bold text-vigilantex-red">VigilantEx Sales Automation</h1>
            <nav>
              <ul className="flex space-x-4">
                <li>
                  <button 
                    className={`px-4 py-2 rounded-md ${activeTab === 'profile' ? 'bg-vigilantex-red text-white' : 'bg-gray-200'}`}
                    onClick={() => setActiveTab('profile')}
                  >
                    Profile Analysis
                  </button>
                </li>
                <li>
                  <button 
                    className={`px-4 py-2 rounded-md ${activeTab === 'company' ? 'bg-vigilantex-red text-white' : 'bg-gray-200'}`}
                    onClick={() => setActiveTab('company')}
                  >
                    Company Analysis
                  </button>
                </li>
                <li>
                  <button 
                    className={`px-4 py-2 rounded-md ${activeTab === 'message' ? 'bg-vigilantex-red text-white' : 'bg-gray-200'}`}
                    onClick={() => setActiveTab('message')}
                  >
                    Message Analysis
                  </button>
                </li>
              </ul>
            </nav>
          </div>
        </header>
        
        <main className="flex-grow container mx-auto p-4 flex flex-col md:flex-row gap-4">
          <section className="w-full md:w-1/2 bg-white rounded-lg shadow-md p-4">
            <InputForm activeTab={activeTab} />
          </section>
          
          <section className="w-full md:w-1/2 bg-white rounded-lg shadow-md p-4 flex flex-col">
            <div className="h-64 bg-gray-900 rounded-md overflow-hidden">
              <Suspense fallback={<LoadingSpinner />}>
                <Canvas camera={{ position: [0, 0, 5], fov: 75 }}>
                  <ambientLight intensity={0.5} />
                  <pointLight position={[10, 10, 10]} />
                  <AIVisualization activeTab={activeTab} />
                  <OrbitControls enableZoom={false} enablePan={false} />
                </Canvas>
              </Suspense>
            </div>
            
            <div className="flex-grow mt-4">
              <ResultsDisplay activeTab={activeTab} />
            </div>
          </section>
        </main>
        
        <footer className="bg-white shadow-md p-4 mt-auto">
          <div className="container mx-auto text-center text-sm text-gray-600">
            &copy; {new Date().getFullYear()} VigilantEx Inc. All rights reserved.
          </div>
        </footer>
      </div>
    </AppProvider>
  );
}

export default App;
```

### /src/context/AppContext.jsx
```jsx
import React, { createContext, useContext, useState } from 'react';
import apiService from '../services/apiService';

// Create context
const AppContext = createContext();

// Custom hook to use the context
export const useAppContext = () => useContext(AppContext);

// Provider component
export const AppProvider = ({ children }) => {
  // State for profile analysis
  const [profileUrl, setProfileUrl] = useState('');
  const [profileData, setProfileData] = useState(null);
  const [profileLoading, setProfileLoading] = useState(false);
  const [profileError, setProfileError] = useState(null);
  const [profileContent, setProfileContent] = useState(null);

  // State for company analysis
  const [companyUrl, setCompanyUrl] = useState('');
  const [companyData, setCompanyData] = useState(null);
  const [companyLoading, setCompanyLoading] = useState(false);
  const [companyError, setCompanyError] = useState(null);
  const [companyContent, setCompanyContent] = useState(null);
  const [decisionMakers, setDecisionMakers] = useState([]);

  // State for message analysis
  const [clientMessage, setClientMessage] = useState('');
  const [messageAnalysis, setMessageAnalysis] = useState(null);
  const [messageLoading, setMessageLoading] = useState(false);
  const [messageError, setMessageError] = useState(null);
  const [responseContent, setResponseContent] = useState(null);

  // State for visualization
  const [processingStage, setProcessingStage] = useState('idle'); // idle, loading, analyzing, generating, complete
  const [outputFormat, setOutputFormat] = useState('email'); // email, linkedin, phone

  // Function to analyze LinkedIn profile
  const analyzeProfile = async () => {
    if (!profileUrl) return;
    
    try {
      setProfileLoading(true);
      setProcessingStage('loading');
      setProfileError(null);
      
      // Call the API service
      setTimeout(() => {
        setProcessingStage('analyzing');
        
        setTimeout(() => {
          setProcessingStage('generating');
          
          apiService.analyzeProfile(profileUrl, outputFormat)
            .then(response => {
              if (response.status === 'success') {
                setProfileData(response.data.profileData);
                setProfileContent(response.data.content);
                setProfileLoading(false);
                setProcessingStage('complete');
              } else {
                throw new Error(response.message || 'Failed to analyze profile');
              }
            })
            .catch(error => {
              setProfileError(error.message || 'An error occurred during profile analysis');
              setProfileLoading(false);
              setProcessingStage('idle');
            });
        }, 1000);
      }, 1000);
      
    } catch (error) {
      setProfileError(error.message || 'An error occurred during profile analysis');
      setProfileLoading(false);
      setProcessingStage('idle');
    }
  };

  // Function to analyze company
  const analyzeCompany = async () => {
    if (!companyUrl) return;
    
    try {
      setCompanyLoading(true);
      setProcessingStage('loading');
      setCompanyError(null);
      
      // Call the API service
      setTimeout(() => {
        setProcessingStage('analyzing');
        
        setTimeout(() => {
          setProcessingStage('generating');
          
          apiService.analyzeCompany(companyUrl, outputFormat)
            .then(response => {
              if (response.status === 'success') {
                setCompanyData(response.data.companyData);
                setDecisionMakers(response.data.decisionMakers);
                setCompanyContent(response.data.content);
                setCompanyLoading(false);
                setProcessingStage('complete');
              } else {
                throw new Error(response.message || 'Failed to analyze company');
              }
            })
            .catch(error => {
              setCompanyError(error.message || 'An error occurred during company analysis');
              setCompanyLoading(false);
              setProcessingStage('idle');
            });
        }, 1000);
      }, 1000);
      
    } catch (error) {
      setCompanyError(error.message || 'An error occurred during company analysis');
      setCompanyLoading(false);
      setProcessingStage('idle');
    }
  };

  // Function to analyze client message
  const analyzeMessage = async () => {
    if (!clientMessage) return;
    
    try {
      setMessageLoading(true);
      setProcessingStage('loading');
      setMessageError(null);
      
      // Call the API service
      setTimeout(() => {
        setProcessingStage('analyzing');
        
        setTimeout(() => {
          setProcessingStage('generating');
          
          apiService.analyzeMessage(clientMessage, outputFormat)
            .then(response => {
              if (response.status === 'success') {
                setMessageAnalysis(response.data.messageAnalysis);
                setResponseContent(response.data.responseContent);
                setMessageLoading(false);
                setProcessingStage('complete');
              } else {
                throw new Error(response.message || 'Failed to analyze message');
              }
            })
            .catch(error => {
              setMessageError(error.message || 'An error occurred during message analysis');
              setMessageLoading(false);
              setProcessingStage('idle');
            });
        }, 1000);
      }, 1000);
      
    } catch (error) {
      setMessageError(error.message || 'An error occurred during message analysis');
      setMessageLoading(false);
      setProcessingStage('idle');
    }
  };

  // Context value
  const value = {
    // Profile analysis
    profileUrl,
    setProfileUrl,
    profileData,
    profileLoading,
    profileError,
    profileContent,
    analyzeProfile,
    
    // Company analysis
    companyUrl,
    setCompanyUrl,
    companyData,
    companyLoading,
    companyError,
    companyContent,
    decisionMakers,
    analyzeCompany,
    
    // Message analysis
    clientMessage,
    setClientMessage,
    messageAnalysis,
    messageLoading,
    messageError,
    responseContent,
    analyzeMessage,
    
    // Shared state
    processingStage,
    outputFormat,
    setOutputFormat
  };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
};

export default AppContext;
```

### /src/services/apiService.js
```javascript
import axios from 'axios';

const API_URL = 'http://localhost:5007/api';

/**
 * Service for making API calls to the backend
 */
const apiService = {
  /**
   * Analyze a LinkedIn profile
   * @param {string} profileUrl - LinkedIn profile URL
   * @param {string} outputFormat - Desired output format (email, linkedin, phone)
   * @returns {Promise<Object>} - Analysis results
   */
  analyzeProfile: async (profileUrl, outputFormat) => {
    try {
      const response = await axios.post(`${API_URL}/profile/analyze`, {
        profileUrl,
        outputFormat
      });
      return response.data;
    } catch (error) {
      console.error('Error analyzing profile:', error);
      throw new Error(error.response?.data?.message || 'Failed to analyze profile');
    }
  },

  /**
   * Analyze a LinkedIn company
   * @param {string} companyUrl - LinkedIn company URL
   * @param {string} outputFormat - Desired output format (email, linkedin, phone)
   * @returns {Promise<Object>} - Analysis results
   */
  analyzeCompany: async (companyUrl, outputFormat) => {
    try {
      const response = await axios.post(`${API_URL}/company/analyze`, {
        companyUrl,
        outputFormat
      });
      return response.data;
    } catch (error) {
      console.error('Error analyzing company:', error);
      throw new Error(error.response?.data?.message || 'Failed to analyze company');
    }
  },

  /**
   * Analyze a client message
   * @param {string} clientMessage - Message from the client
   * @param {string} outputFormat - Desired output format (email, linkedin, phone)
   * @returns {Promise<Object>} - Analysis results
   */
  analyzeMessage: async (clientMessage, outputFormat) => {
    try {
      const response = await axios.post(`${API_URL}/message/analyze`, {
        clientMessage,
        outputFormat
      });
      return response.data;
    } catch (error) {
      console.error('Error analyzing message:', error);
      throw new Error(error.response?.data?.message || 'Failed to analyze message');
    }
  },

  /**
   * Check API health
   * @returns {Promise<Object>} - Health status
   */
  checkHealth: async () => {
    try {
      const response = await axios.get(`${API_URL}/health`);
      return response.data;
    } catch (error) {
      console.error('Error checking API health:', error);
      throw new Error('API is not available');
    }
  }
};

export default apiService;
```

### /src/components/forms/InputForm.jsx
```jsx
import React from 'react';
import { useAppContext } from '../../context/AppContext';

const InputForm = ({ activeTab }) => {
  const {
    // Profile analysis
    profileUrl,
    setProfileUrl,
    profileLoading,
    analyzeProfile,
    
    // Company analysis
    companyUrl,
    setCompanyUrl,
    companyLoading,
    analyzeCompany,
    
    // Message analysis
    clientMessage,
    setClientMessage,
    messageLoading,
    analyzeMessage,
    
    // Shared state
    outputFormat,
    setOutputFormat
  } = useAppContext();

  const handleSubmit = (e) => {
    e.preventDefault();
    
    if (activeTab === 'profile') {
      analyzeProfile();
    } else if (activeTab === 'company') {
      analyzeCompany();
    } else if (activeTab === 'message') {
      analyzeMessage();
    }
  };

  return (
    <div className="w-full">
      <h2 className="text-xl font-semibold mb-4">
        {activeTab === 'profile' && 'LinkedIn Profile Analysis'}
        {activeTab === 'company' && 'Company Analysis'}
        {activeTab === 'message' && 'Client Message Analysis'}
      </h2>
      
      <form onSubmit={handleSubmit} className="space-y-4">
        {/* Profile URL Input */}
        {activeTab === 'profile' && (
          <div>
            <label htmlFor="profileUrl" className="block text-sm font-medium text-gray-700 mb-1">
              LinkedIn Profile URL
            </label>
            <input
              type="url"
              id="profileUrl"
              value={profileUrl}
              onChange={(e) => setProfileUrl(e.target.value)}
              placeholder="https://www.linkedin.com/in/username"
              className="w-full px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-vigilantex-red"
              required
            />
            <p className="mt-1 text-sm text-gray-500">
              Enter the LinkedIn URL of the person you want to analyze
            </p>
          </div>
        )}
        
        {/* Company URL Input */}
        {activeTab === 'company' && (
          <div>
            <label htmlFor="companyUrl" className="block text-sm font-medium text-gray-700 mb-1">
              LinkedIn Company URL
            </label>
            <input
              type="url"
              id="companyUrl"
              value={companyUrl}
              onChange={(e) => setCompanyUrl(e.target.value)}
              placeholder="https://www.linkedin.com/company/name"
              className="w-full px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-vigilantex-red"
              required
            />
            <p className="mt-1 text-sm text-gray-500">
              Enter the LinkedIn URL of the company you want to analyze
            </p>
          </div>
        )}
        
        {/* Client Message Input */}
        {activeTab === 'message' && (
          <div>
            <label htmlFor="clientMessage" className="block text-sm font-medium text-gray-700 mb-1">
              Client Message
            </label>
            <textarea
              id="clientMessage"
              value={clientMessage}
              onChange={(e) => setClientMessage(e.target.value)}
              placeholder="Paste the client's message here..."
              rows={6}
              className="w-full px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-vigilantex-red"
              required
            />
            <p className="mt-1 text-sm text-gray-500">
              Paste the client's email or message for analysis and response generation
            </p>
          </div>
        )}
        
        {/* Output Format Selection */}
        <div>
          <label className="block text-sm font-medium text-gray-700 mb-1">
            Output Format
          </label>
          <div className="flex space-x-4">
            <label className="inline-flex items-center">
              <input
                type="radio"
                value="email"
                checked={outputFormat === 'email'}
                onChange={() => setOutputFormat('email')}
                className="form-radio text-vigilantex-red"
              />
              <span className="ml-2">Email</span>
            </label>
            <label className="inline-flex items-center">
              <input
                type="radio"
                value="linkedin"
                checked={outputFormat === 'linkedin'}
                onChange={() => setOutputFormat('linkedin')}
                className="form-radio text-vigilantex-red"
              />
              <span className="ml-2">LinkedIn Message</span>
            </label>
            <label className="inline-flex items-center">
              <input
                type="radio"
                value="phone"
                checked={outputFormat === 'phone'}
                onChange={() => setOutputFormat('phone')}
                className="form-radio text-vigilantex-red"
              />
              <span className="ml-2">Phone Script</span>
            </label>
          </div>
        </div>
        
        {/* Submit Button */}
        <div>
          <button
            type="submit"
            disabled={
              (activeTab === 'profile' && (!profileUrl || profileLoading)) ||
              (activeTab === 'company' && (!companyUrl || companyLoading)) ||
              (activeTab === 'message' && (!clientMessage || messageLoading))
            }
            className="w-full px-4 py-2 bg-vigilantex-red text-white font-medium rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-vigilantex-red disabled:bg-gray-400 disabled:cursor-not-allowed"
          >
            {(activeTab === 'profile' && profileLoading) ||
             (activeTab === 'company' && companyLoading) ||
             (activeTab === 'message' && messageLoading)
              ? 'Processing...'
              : 'Generate Content'}
          </button>
        </div>
      </form>
    </div>
  );
};

export default InputForm;
```

### /src/components/visualization/AIVisualization.jsx
```jsx
import React, { useRef, useEffect } from 'react';
import { useFrame } from '@react-three/fiber';
import { useAppContext } from '../../context/AppContext';
import * as THREE from 'three';

// AI Visualization component using Three.js
const AIVisualization = ({ activeTab }) => {
  const { processingStage } = useAppContext();
  
  // Create refs for the objects we'll animate
  const groupRef = useRef();
  const sphereRef = useRef();
  const particlesRef = useRef();
  
  // Create particles
  useEffect(() => {
    if (particlesRef.current) {
      const particleCount = 500;
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      
      const color = new THREE.Color();
      
      for (let i = 0; i < particleCount; i++) {
        // Position
        const x = (Math.random() - 0.5) * 10;
        const y = (Math.random() - 0.5) * 10;
        const z = (Math.random() - 0.5) * 10;
        
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
        
        // Color
        color.setHSL(Math.random(), 0.7, 0.5);
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
        
        // Size
        sizes[i] = Math.random() * 0.1 + 0.05;
      }
      
      particlesRef.current.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particlesRef.current.geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      particlesRef.current.geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    }
  }, []);
  
  // Animation based on processing stage
  useFrame((state, delta) => {
    if (groupRef.current) {
      // Base rotation
      groupRef.current.rotation.y += delta * 0.2;
      
      // Stage-specific animations
      switch (processingStage) {
        case 'idle':
          if (sphereRef.current) {
            sphereRef.current.scale.setScalar(1 + Math.sin(state.clock.elapsedTime) * 0.1);
          }
          if (particlesRef.current) {
            particlesRef.current.material.opacity = 0.3;
          }
          break;
          
        case 'loading':
          if (sphereRef.current) {
            sphereRef.current.scale.setScalar(1 + Math.sin(state.clock.elapsedTime * 5) * 0.2);
          }
          if (particlesRef.current) {
            particlesRef.current.material.opacity = 0.5;
            // Make particles move toward center
            const positions = particlesRef.current.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
              positions[i] += (0 - positions[i]) * 0.01;
              positions[i + 1] += (0 - positions[i + 1]) * 0.01;
              positions[i + 2] += (0 - positions[i + 2]) * 0.01;
            }
            particlesRef.current.geometry.attributes.position.needsUpdate = true;
          }
          break;
          
        case 'analyzing':
          if (sphereRef.current) {
            sphereRef.current.scale.setScalar(1.5 + Math.sin(state.clock.elapsedTime * 3) * 0.2);
          }
          if (particlesRef.current) {
            particlesRef.current.material.opacity = 0.8;
            // Make particles orbit
            const positions = particlesRef.current.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
              const x = positions[i];
              const z = positions[i + 2];
              const angle = delta * 0.5;
              positions[i] = x * Math.cos(angle) - z * Math.sin(angle);
              positions[i + 2] = x * Math.sin(angle) + z * Math.cos(angle);
            }
            particlesRef.current.geometry.attributes.position.needsUpdate = true;
          }
          break;
          
        case 'generating':
          if (sphereRef.current) {
            sphereRef.current.scale.setScalar(2 + Math.sin(state.clock.elapsedTime * 2) * 0.3);
          }
          if (particlesRef.current) {
            particlesRef.current.material.opacity = 1;
            // Make particles expand outward
            const positions = particlesRef.current.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
              const x = positions[i];
              const y = positions[i + 1];
              const z = positions[i + 2];
              const length = Math.sqrt(x * x + y * y + z * z);
              if (length < 5) {
                positions[i] += x / length * 0.05;
                positions[i + 1] += y / length * 0.05;
                positions[i + 2] += z / length * 0.05;
              }
            }
            particlesRef.current.geometry.attributes.position.needsUpdate = true;
          }
          break;
          
        case 'complete':
          if (sphereRef.current) {
            sphereRef.current.scale.setScalar(1.5 + Math.sin(state.clock.elapsedTime) * 0.1);
          }
          if (particlesRef.current) {
            particlesRef.current.material.opacity = 0.7;
            // Make particles form a stable pattern
            const positions = particlesRef.current.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
              const x = positions[i];
              const y = positions[i + 1];
              const z = positions[i + 2];
              const length = Math.sqrt(x * x + y * y + z * z);
              if (length > 3 && length < 4) {
                positions[i] += (3.5 * x / length - x) * 0.05;
                positions[i + 1] += (3.5 * y / length - y) * 0.05;
                positions[i + 2] += (3.5 * z / length - z) * 0.05;
              } else if (length < 3) {
                positions[i] += (3 * x / length - x) * 0.05;
                positions[i + 1] += (3 * y / length - y) * 0.05;
                positions[i + 2] += (3 * z / length - z) * 0.05;
              } else if (length > 4) {
                positions[i] += (4 * x / length - x) * 0.05;
                positions[i + 1] += (4 * y / length - y) * 0.05;
                positions[i + 2] += (4 * z / length - z) * 0.05;
              }
            }
            particlesRef.current.geometry.attributes.position.needsUpdate = true;
          }
          break;
          
        default:
          break;
      }
    }
  });
  
  // Get color based on active tab
  const getColor = () => {
    switch (activeTab) {
      case 'profile':
        return '#ff3333'; // Brighter red
      case 'company':
        return '#3366ff'; // Blue
      case 'message':
        return '#33cc33'; // Green
      default:
        return '#ff0000'; // Default red
    }
  };
  
  return (
    <group ref={groupRef}>
      {/* Central sphere representing the AI core */}
      <mesh ref={sphereRef}>
        <sphereGeometry args={[0.5, 32, 32]} />
        <meshStandardMaterial 
          color={getColor()} 
          emissive={getColor()} 
          emissiveIntensity={0.5} 
          metalness={0.8} 
          roughness={0.2} 
        />
      </mesh>
      
      {/* Particles representing data and processing */}
      <points ref={particlesRef}>
        <bufferGeometry />
        <pointsMaterial 
          size={0.1} 
          vertexColors 
          transparent 
          opacity={0.5} 
          blending={THREE.AdditiveBlending} 
        />
      </points>
    </group>
  );
};

export default AIVisualization;
```

### /src/components/results/ResultsDisplay.jsx
```jsx
import React from 'react';
import { useAppContext } from '../../context/AppContext';

const ResultsDisplay = ({ activeTab }) => {
  const {
    // Profile analysis
    profileData,
    profileContent,
    profileLoading,
    profileError,
    
    // Company analysis
    companyData,
    companyContent,
    decisionMakers,
    companyLoading,
    companyError,
    
    // Message analysis
    messageAnalysis,
    responseContent,
    messageLoading,
    messageError,
    
    // Shared state
    processingStage,
    outputFormat
  } = useAppContext();

  // Function to copy content to clipboard
  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text)
      .then(() => {
        alert('Content copied to clipboard!');
      })
      .catch(err => {
        console.error('Failed to copy: ', err);
      });
  };

  // Render loading state
  if (
    (activeTab === 'profile' && profileLoading) ||
    (activeTab === 'company' && companyLoading) ||
    (activeTab === 'message' && messageLoading)
  ) {
    return (
      <div className="flex flex-col items-center justify-center h-full">
        <p className="text-lg font-medium text-gray-700 mb-2">
          {processingStage === 'loading' && 'Collecting data...'}
          {processingStage === 'analyzing' && 'Analyzing information...'}
          {processingStage === 'generating' && 'Generating content...'}
        </p>
        <div className="w-12 h-12 border-4 border-vigilantex-red border-t-transparent rounded-full animate-spin"></div>
      </div>
    );
  }

  // Render error state
  if (
    (activeTab === 'profile' && profileError) ||
    (activeTab === 'company' && companyError) ||
    (activeTab === 'message' && messageError)
  ) {
    return (
      <div className="bg-red-50 p-4 rounded-md">
        <h3 className="text-lg font-medium text-red-800">Error</h3>
        <p className="mt-2 text-red-700">
          {activeTab === 'profile' && profileError}
          {activeTab === 'company' && companyError}
          {activeTab === 'message' && messageError}
        </p>
      </div>
    );
  }

  // Render profile results
  if (activeTab === 'profile' && profileData && profileContent) {
    return (
      <div className="space-y-4">
        <div className="bg-gray-50 p-4 rounded-md">
          <h3 className="text-lg font-medium text-gray-800 mb-2">Profile Insights</h3>
          <div className="space-y-2">
            <p><span className="font-medium">Name:</span> {profileData.name}</p>
            <p><span className="font-medium">Title:</span> {profileData.title}</p>
            <p><span className="font-medium">Company:</span> {profileData.company}</p>
            <p><span className="font-medium">Location:</span> {profileData.location}</p>
            
            <div>
              <p className="font-medium">Experience:</p>
              <ul className="list-disc pl-5">
                {profileData.experience.map((exp, index) => (
                  <li key={index}>{exp.title} at {exp.company} ({exp.duration})</li>
                ))}
              </ul>
            </div>
            
            <div>
              <p className="font-medium">Interests:</p>
              <div className="flex flex-wrap gap-2 mt-1">
                {profileData.interests.map((interest, index) => (
                  <span key={index} className="px-2 py-1 bg-gray-200 rounded-md text-sm">
                    {interest}
                  </span>
                ))}
              </div>
            </div>
          </div>
        </div>
        
        <div className="bg-white border border-gray-200 p-4 rounded-md">
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-lg font-medium text-gray-800">Generated Content</h3>
            <span className="px-2 py-1 bg-gray-200 rounded-md text-sm">
              {outputFormat === 'email' && 'Email Format'}
              {outputFormat === 'linkedin' && 'LinkedIn Message'}
              {outputFormat === 'phone' && 'Phone Script'}
            </span>
          </div>
          
          <div className="whitespace-pre-wrap bg-gray-50 p-3 rounded-md font-mono text-sm">
            {profileContent}
          </div>
          
          <button
            onClick={() => copyToClipboard(profileContent)}
            className="mt-3 px-4 py-2 bg-vigilantex-red text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-vigilantex-red"
          >
            Copy to Clipboard
          </button>
        </div>
      </div>
    );
  }

  // Render company results
  if (activeTab === 'company' && companyData && companyContent) {
    return (
      <div className="space-y-4">
        <div className="bg-gray-50 p-4 rounded-md">
          <h3 className="text-lg font-medium text-gray-800 mb-2">Company Insights</h3>
          <div className="space-y-2">
            <p><span className="font-medium">Name:</span> {companyData.name}</p>
            <p><span className="font-medium">Industry:</span> {companyData.industry}</p>
            <p><span className="font-medium">Size:</span> {companyData.size}</p>
            <p><span className="font-medium">Location:</span> {companyData.location}</p>
            <p><span className="font-medium">Website:</span> {companyData.website}</p>
            
            <div>
              <p className="font-medium">Specialties:</p>
              <div className="flex flex-wrap gap-2 mt-1">
                {companyData.specialties.map((specialty, index) => (
                  <span key={index} className="px-2 py-1 bg-gray-200 rounded-md text-sm">
                    {specialty}
                  </span>
                ))}
              </div>
            </div>
          </div>
        </div>
        
        <div className="bg-gray-50 p-4 rounded-md">
          <h3 className="text-lg font-medium text-gray-800 mb-2">Key Decision Makers</h3>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
            {decisionMakers.map((person, index) => (
              <div key={index} className="bg-white p-3 rounded-md shadow-sm">
                <p className="font-medium">{person.name}</p>
                <p className="text-sm text-gray-600">{person.title}</p>
                <a 
                  href={person.linkedinUrl} 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="text-sm text-blue-600 hover:underline"
                >
                  LinkedIn Profile
                </a>
              </div>
            ))}
          </div>
        </div>
        
        <div className="bg-white border border-gray-200 p-4 rounded-md">
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-lg font-medium text-gray-800">Generated Content</h3>
            <span className="px-2 py-1 bg-gray-200 rounded-md text-sm">
              {outputFormat === 'email' && 'Email Format'}
              {outputFormat === 'linkedin' && 'LinkedIn Message'}
              {outputFormat === 'phone' && 'Phone Script'}
            </span>
          </div>
          
          <div className="whitespace-pre-wrap bg-gray-50 p-3 rounded-md font-mono text-sm">
            {companyContent}
          </div>
          
          <button
            onClick={() => copyToClipboard(companyContent)}
            className="mt-3 px-4 py-2 bg-vigilantex-red text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-vigilantex-red"
          >
            Copy to Clipboard
          </button>
        </div>
      </div>
    );
  }

  // Render message analysis results
  if (activeTab === 'message' && messageAnalysis && responseContent) {
    return (
      <div className="space-y-4">
        <div className="bg-gray-50 p-4 rounded-md">
          <h3 className="text-lg font-medium text-gray-800 mb-2">Message Analysis</h3>
          <div className="space-y-2">
            <p>
              <span className="font-medium">Sentiment:</span> 
              <span className={`ml-2 px-2 py-1 rounded-md text-sm ${
                messageAnalysis.sentiment === 'positive' ? 'bg-green-100 text-green-800' :
                messageAnalysis.sentiment === 'negative' ? 'bg-red-100 text-red-800' :
                'bg-yellow-100 text-yellow-800'
              }`}>
                {messageAnalysis.sentiment}
              </span>
            </p>
            
            <div>
              <p className="font-medium">Topics Identified:</p>
              <div className="flex flex-wrap gap-2 mt-1">
                {messageAnalysis.topics.map((topic, index) => (
                  <span key={index} className="px-2 py-1 bg-gray-200 rounded-md text-sm">
                    {topic}
                  </span>
                ))}
              </div>
            </div>
            
            <div>
              <p className="font-medium">Questions Detected:</p>
              <ul className="list-disc pl-5">
                {messageAnalysis.questions.map((question, index) => (
                  <li key={index}>{question}</li>
                ))}
              </ul>
            </div>
          </div>
        </div>
        
        <div className="bg-white border border-gray-200 p-4 rounded-md">
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-lg font-medium text-gray-800">Generated Response</h3>
            <span className="px-2 py-1 bg-gray-200 rounded-md text-sm">
              {outputFormat === 'email' && 'Email Format'}
              {outputFormat === 'linkedin' && 'LinkedIn Message'}
              {outputFormat === 'phone' && 'Phone Script'}
            </span>
          </div>
          
          <div className="whitespace-pre-wrap bg-gray-50 p-3 rounded-md font-mono text-sm">
            {responseContent}
          </div>
          
          <button
            onClick={() => copyToClipboard(responseContent)}
            className="mt-3 px-4 py-2 bg-vigilantex-red text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-vigilantex-red"
          >
            Copy to Clipboard
          </button>
        </div>
      </div>
    );
  }

  // Default state (no data yet)
  return (
    <div className="flex flex-col items-center justify-center h-full text-center p-4">
      <h3 className="text-xl font-medium text-gray-700 mb-2">No Data Yet</h3>
      <p className="text-gray-500 mb-4">
        {activeTab === 'profile' && 'Enter a LinkedIn profile URL and click "Generate Content" to analyze a potential client.'}
        {activeTab === 'company' && 'Enter a LinkedIn company URL and click "Generate Content" to analyze a company and identify key decision-makers.'}
        {activeTab === 'message' && 'Paste a client message and click "Generate Content" to analyze and generate a response.'}
      </p>
      <div className="w-16 h-16 text-gray-300">
        {activeTab === 'profile' && (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
          </svg>
        )}
        {activeTab === 'company' && (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4" />
          </svg>
        )}
        {activeTab === 'message' && (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
          </svg>
        )}
      </div>
    </div>
  );
};

export default ResultsDisplay;
```

### /src/components/common/LoadingSpinner.jsx
```jsx
import React from 'react';

const LoadingSpinner = () => {
  return (
    <div className="flex items-center justify-center h-full w-full">
      <div className="w-12 h-12 border-4 border-vigilantex-red border-t-transparent rounded-full animate-spin"></div>
    </div>
  );
};

export default LoadingSpinner;
```

### /src/components/common/Button.jsx
```jsx
import React from 'react';

const Button = ({ 
  children, 
  onClick, 
  type = 'button', 
  disabled = false, 
  variant = 'primary',
  className = '',
  fullWidth = false
}) => {
  const baseClasses = "px-4 py-2 rounded-md font-medium focus:outline-none focus:ring-2 focus:ring-offset-2";
  
  const variantClasses = {
    primary: "bg-vigilantex-red text-white hover:bg-red-700 focus:ring-vigilantex-red",
    secondary: "bg-gray-200 text-gray-800 hover:bg-gray-300 focus:ring-gray-500",
    outline: "bg-transparent text-vigilantex-red border border-vigilantex-red hover:bg-red-50 focus:ring-vigilantex-red"
  };
  
  const widthClass = fullWidth ? "w-full" : "";
  const disabledClass = disabled ? "opacity-50 cursor-not-allowed" : "";
  
  return (
    <button
      type={type}
      onClick={onClick}
      disabled={disabled}
      className={`${baseClasses} ${variantClasses[variant]} ${widthClass} ${disabledClass} ${className}`}
    >
      {children}
    </button>
  );
};

export default Button;
```

### /vite.config.js
```javascript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    host: '0.0.0.0',
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
        secure: false,
      }
    }
  }
});
```

### /tailwind.config.js
```javascript
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        'vigilantex-red': '#ff0000',
        'vigilantex-black': '#000000',
      },
    },
  },
  plugins: [],
}
```

## Project Overview

VigilantEx Sales Automation is a modern web application designed to help sales professionals generate personalized outreach content by analyzing LinkedIn profiles, companies, and client messages. The application uses AI to create tailored responses and content for different communication channels including email, LinkedIn messages, and phone scripts.

### Current Project Status

The frontend is built with React 19.0.0 and uses a modern tech stack:
- Vite for build tooling and development server
- TailwindCSS for styling
- Three.js with React Three Fiber for 3D visualizations
- Axios for API calls to the backend service

The application has three main features:
1. **Profile Analysis**: Analyses LinkedIn profiles to generate personalized outreach content
2. **Company Analysis**: Examines company profiles to identify key decision-makers and create targeted messaging
3. **Message Analysis**: Analyzes client messages to generate appropriate responses

Each analysis flow includes a visually engaging 3D visualization that shows the processing stages (idle, loading, analyzing, generating, complete) with animated particle effects.

### Architecture

The application follows a clean architecture pattern:
- **Components**: Organized by feature and common elements
- **Context**: Uses React Context API for state management
- **Services**: API service layer for backend communication
- **Visualization**: Three.js based visualizations for the AI processing

### Backend Integration

The application is designed to communicate with a backend server running on port 5007 (as configured in apiService.js), but the Vite development server is set up to proxy API requests to port 5000. The backend is expected to provide endpoints for:
- `/api/profile/analyze`
- `/api/company/analyze`
- `/api/message/analyze`
- `/api/health`

### Future Direction

Based on the codebase, the project appears to be in a well-structured but early stage of development. Key areas for future development might include:

1. **Authentication and User Management**: The application currently lacks login and user management features
2. **History and Saved Analyses**: Adding capabilities to save and revisit previous analyses
3. **Expanded AI Capabilities**: Potentially enhancing the AI analysis for deeper insights
4. **Team Collaboration**: Adding features to share analyses with team members
5. **Integration with CRM Systems**: Connecting with popular CRM tools to sync data
6. **Mobile Optimization**: Enhancing the responsive design for mobile users
7. **Analytics Dashboard**: Adding metrics and analytics on outreach effectiveness

The visualization component is quite sophisticated and could be further enhanced with more advanced Three.js features to create even more engaging visual feedback.

The project uses modern React patterns including hooks and context for state management, but could potentially benefit from more specialized state management if complexity increases.